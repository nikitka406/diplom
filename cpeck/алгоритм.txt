1. Входные данные
    1.1. Задаем координаты для городов
    1.2. Находим расстояния между городами
    1.3. Время перемещения между городами, это округление расстояния между городами
    1.4. Задаем число скважин
    1.5. Число рабочих дней. На одну скважину тратим 2 дня
    1.6. Считаем сколько скважин всего, чтобы знать сколько выделить ТС
    1.7. Начало работы рандомно
    1.8. Конец работы, это начало работы + время работы для одно ТС на этой локации
2. Начальное решение
    2.1. Создаем стартовое решение (OneCarOneLocation), на одну скважину одно ТС
    2.2. Создаем переменные задачи
    2.3. В "у[0][k]" ставим 0 так как каждое ТС выезжает из депо, значит оно там было
    2.4. Идем по массиву скважин, если на локации >= 1 скважины, то последней не используемой машине назначаем посящение
    этой локации. Причем и туда и обратно
    2.5. Отмечаем, что К-ое ТС посетило Ж-ого клиента (У[][])
    2.6. Если скважин больше чем 1 то время работы К-ого ТС = время работы на этой локации делить на число скважин
    2.7. Время начало работы на данной локации для К-ого ТС равно либо по регламенту либо позже
    2.8. Считаем и запоминаем значение целевой функции
    2.9. Проверяем граничные условия
3. Оптимизируем начальное решение
    3.1. Аналогично для других переменных задач
    3.2. Удаляем ТС, если это позволяют гран усл DeleteCarNonNarushOgr
        3.2.1. Создаем копию стартого решения
        3.2.2. Идем по массиву с кол-вом скважин, ввыбираем у которых скважин больше одной
        3.2.3. Выбираем только те машины у следом за которыми едет еще одна в эту же локацию
        3.2.4. После того как выбрали, вносим изменения в остальные переменные задачи
        3.2.5. Проверяем выполнимость гран усл
        3.2.6. Если не испортились, то сохраняем изменения в оригинальные переменные задачи
        3.2.7. Если испортились, то возвращаем последнии изменения
    3.3. Уменьшаем размерность решения/удаляем не нужные ТС (DeleteNotUsedCar)
        3.3.1. По матрице У[][] ищем ТС которое никуда не едет
        3.3.2. После него ищем перрвое попавшиеся ТС которое работате
        3.3.3. Передвигаем на его место с помощью функции Rewriting, а старое место зануляем
        3.3.4. Создаем новое решение но уже с меньшим колличество ТС
        3.3.5. И перезаписываем решение
    3.4. Проверяем гран усл
    3.5. Создаем хранилище решений X[n][0] - номер решение, а с X[n][1] - само решение


    3.4. Берем рандомного клиента, ищем какая машина его обслуживает
    3.5. Проверяем что он лист, следующим образом, если время прибытия к этому клиенту на этой машине максимальное, то он лист
    3.6. Если он не лист, то ищем нового рандомного клиента
    3.7.
