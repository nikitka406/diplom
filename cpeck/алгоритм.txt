1. Входные данные
    1.1. Задаем координаты для городов
    1.2. Находим расстояния между городами
    1.3. Время перемещения между городами, это округление расстояния между городами
    1.4. Задаем число скважин
    1.5. Число рабочих дней. На одну скважину тратим 2 дня
    1.6. Считаем сколько скважин всего, чтобы знать сколько выделить ТС
    1.7. Начало работы рандомно
    1.8. Конец работы, это начало работы + время работы для одно ТС на этой локации
2. Начальное решение
    2.1. Создаем стартовое решение (OneCarOneLocation), на одну скважину одно ТС
    2.2. Создаем переменные задачи
    2.3. В "у[0][k]" ставим 0 так как каждое ТС выезжает из депо, значит оно там было
    2.4. Идем по массиву скважин, если на локации >= 1 скважины, то последней не используемой машине назначаем посящение
    этой локации. Причем и туда и обратно
    2.5. Отмечаем, что К-ое ТС посетило Ж-ого клиента (У[][])
    2.6. Если скважин больше чем 1 то время работы К-ого ТС = время работы на этой локации делить на число скважин
    2.7. Время начало работы на данной локации для К-ого ТС равно либо по регламенту либо позже
    2.8. Считаем и запоминаем значение целевой функции
    2.9. Проверяем граничные условия
3. Оптимизируем начальное решение
    3.1. Аналогично для других переменных задач
    3.2. Удаляем ТС, если это позволяют гран усл DeleteCarNonNarushOgr
        3.2.1. Создаем копию стартого решения
        3.2.2. Идем по массиву с кол-вом скважин, ввыбираем у которых скважин больше одной
        3.2.3. Выбираем только те машины у следом за которыми едет еще одна в эту же локацию
        3.2.4. После того как выбрали, вносим изменения в остальные переменные задачи
        3.2.5. Проверяем выполнимость гран усл
        3.2.6. Если не испортились, то сохраняем изменения в оригинальные переменные задачи
        3.2.7. Если испортились, то возвращаем последнии изменения
    3.3. Уменьшаем размерность решения/удаляем не нужные ТС (DeleteNotUsedCar)
        3.3.1. По матрице У[][] ищем ТС которое никуда не едет
        3.3.2. После него ищем перрвое попавшиеся ТС которое работате
        3.3.3. Передвигаем на его место с помощью функции Rewriting, а старое место зануляем
        3.3.4. Создаем новое решение но уже с меньшим колличество ТС
        3.3.5. И перезаписываем решение
    3.4. Проверяем гран усл
    3.5. Создаем хранилище решений X[n][0] - номер решение, а с X[n][1] - само решение
пересмотреть туда обратно

    3.4. Берем рандомного клиента, ищем какая машина его обслуживает
    3.5. Проверяем что он лист, следующим образом, если время прибытия к этому клиенту на этой машине максимальное, то он лист
    3.6. Если он не лист, то ищем нового рандомного клиента
    3.7.





№ Скрещивание по АЕХ
1. НА вход получаем две последовательности посещение из двух разных решений.
    1.1. последовательность выглядит следующим образом
                012035640
                000000000
    1.3. У каждой ячейки есть доп ячейка, которая говорит, что из этого конкретного города в этом решении нельзя ехать в следующий
2. Получаем размер каждой из последовательности
3. flagAll создаем флаг для всего нового решения, что этот город уже посещен в новом решении
4. Создаем флаг отвечающий за сколько раз можно заехать к клиенту, но на разных машинах!!!
5. Делаем цикл по самой длинной послеловательгности, но сначало отдельно для первой машины
    5.1. Создаем локальный флаг для первой машины
    5.2. Добавляем первые два города в ребенка
    5.3. Ставим флаг в последовательности из которой берем ребро в доп ячееки (что нельзя из него ехать в этом решении),
    конкретно из 0 в первой последовательности не едем теперь
    5.4. Расставляем флажки локально для первой машины и для общего решения
    5.5. Уменьшаем ол-во машин которые к этому клиенту могут приехать
    5.6. ЗАпускаем рекурсивный поиск
        5.6.1. RecursiveSearchSosedFromAex на вход, массив для ребенка, индекс куда хотим вставить следующео соседа в последовательности
        , в какую последовательность едем, из какой последовательности едем, индекм откуда едем, локальный флаг, глобальный флаг,
        массив количество посещений клиентов
        5.6.2. Узнаем номер последнего посещенного клиента другой последовательности bufer_out[i_out][0] в bufer_in
        5.6.3. ДАлее понимаем какой сам по себе вновь прибывший клиент
            5.6.3.1. Исключение смотрим что этот город еще можно вставлять, в этот маршрут и что у него есть свободные скважины и
            что конкретно это ребро мы еще не использовали
                 5.6.3.1.1. Добавляем следующий город по цепочке в ребенка
                 5.6.3.1.2. Ставим флаг в последовательности из которой берем ребро в доп ячееки (что нельзя из него ехать в этом решении)
                 5.6.3.1.3. Расставляем флажки локально для первой машины и для общего решения
                 5.6.3.1.4. Уменьшаем кол-во машин которые к этому клиенту могут приехать
                 5.6.3.1.5. ЗАпускаем рекурсивный поиск
            5.6.3.2. Исключение если конкретно это ребро в этом решении уже использовали
                5.6.3.2.1. Выбираю другое ребро но из такого же начала, но которое не посещали в этом маршруте,
                у которого еще есть свободные скважины (AnotherEdgeWithTheSameBeginning)
                    5.6.3.2.1.1. Ставим флаг, если не найдем то вернем что не нашли
                    5.6.3.2.1.2. bufer_in[i][0] == new_start нашли кокой-то выезд из такого же города
                    5.6.3.2.1.3. bufer_in[i][1] == 0 мы из него еще не выезжали
                    5.6.3.2.1.4. flag[ bufer_in[i][0] ] == 0 в этом маршруте еще не посещали
                    5.6.3.2.1.5. countOfRaces[bufer_in[i][0]] > 0 есть свободные скважины
                    5.6.3.2.1.6. если не получается вернем -1, что означает что не нашли
                5.6.3.2.2. Если нашли то добавляем, если нет, то идем дальше по исключениям
            5.6.3.3. Исключение если на этом ТС уже посещали, или у этого клиента нет свободных скважин
                5.6.3.3.1. Берем рандомного клиента + узнаем его номер
                5.6.3.3.2. Будем искать пока не найдем такого, который подходит под следующие описание
                    5.6.3.3.2.1. не посещали на этой машине + есть свободные скважины + из него никуда не ехали в этом решении
                    5.6.3.3.2.2. останавливаем если перебрал число раз, равное числу вершин
                5.6.3.3.3. Если нашли рандомное число то рассматриваем исключения рандомный клиент ноль или нет
                    5.6.3.3.3.1. Для каждого исключения по отработтаной схеме
                5.6.3.3.4. Если вывалились из вайла, потому что долго ждали, поэтому возвращаем машину в депо
            5.6.3.4. Исключение если встретили 0 (Машина вернулась в начало)

    5.7. Обнуляем локальный флаг для каждой машине
    5.8. +1 машина к используемым и сдвигаем индекс последовательности на один
    5.9. дальше запускаем ваил


№ Скрещивание по АЕХ
1. НА вход получаем две последовательности посещение из двух разных решений.
    1.1. последовательность выглядит следующим образом
                012035640
                000000000
    1.3. У каждой ячейки есть доп ячейка, которая говорит, что из этого конкретного города в этом решении нельзя ехать в следующий
2. В ребенка вставляем 0
3. Создаем флаги (для машины и решения)
4. Выбираем первое ребро
    4.1. Ищем минимальное время начала
    4.2. Считаем сколько таких начал
    4.3. Добавляем всех таких клиентов у которых одинаковое минимальное время прибытия
    4.4. Для каждого  из этих объектов сохраняем время окончания
    4.5. Ищем мимнимальное время ркрнчания
    4.6. Сохраняем номера всех таких клиентов у которых совпадает время окончания
    4.7. И выбираем рандомног из них
5. Расставляем флаги
6. Добавляем в ребенка первое ребро
7. НАходим индекс вновь прибывшего в первом и втором решении
8. Запоминаем кто идет следом у каждого из них
9. Смотрим какое ребро короче по нему и идем с помощью рекурсии RecursiveSearchSosedFromHGreX, но с  доп настройками:
если i < j i не ноль, если i < j j не ноль, Если j < i и j не ноль, Если j < i и j не ноль





№ Процедура всеобщего скрещивания GetNewSolution
    1. Выбираем сценарий для скрещивания, варианты на рандомный выбор
        1.1. Один рандомный, один с самым плохой целевой функцией
        1.2. Два рандомных
    2. Выбираю способ сохранения нового решения
        2.1. Удалить просто самого худшего
        2.2. Удалить самого худшего родителя
    3. Выбираю оператор, который будем скрешещивать решение

